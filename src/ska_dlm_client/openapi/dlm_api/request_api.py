# coding: utf-8

"""merged spec

merged spec

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""
# noqa: E501

import warnings
from typing import Any, Dict, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, validate_call
from typing_extensions import Annotated

from ska_dlm_client.openapi.api_client import ApiClient, RequestSerialized
from ska_dlm_client.openapi.api_response import ApiResponse
from ska_dlm_client.openapi.rest import RESTResponseType


class RequestApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def query_data_item(
        self,
        item_name: Annotated[
            Optional[StrictStr],
            Field(description="could be empty, in which case the first 1000 items are returned."),
        ] = None,
        oid: Annotated[
            Optional[StrictStr],
            Field(description="Return data_items referred to by the OID provided."),
        ] = None,
        uid: Annotated[
            Optional[StrictStr],
            Field(description="Return data_item referred to by the UID provided."),
        ] = None,
        storage_id: Annotated[
            Optional[StrictStr],
            Field(description="Return data_item referred to by a given storage_id."),
        ] = None,
        params: Annotated[
            Optional[StrictStr], Field(description="specify the query parameters")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Optional[object]]:
        """Query Data Item

        Query a data_item.  At least one of item_name, oid, uid, or params is required.

        Parameters
        ----------
        item_name : str
            could be empty, in which case the first 1000 items are
            returned.
        oid : str
            Return data_items referred to by the OID provided.
        uid : str
            Return data_item referred to by the UID provided.
        storage_id : str
            Return data_item referred to by a given storage_id.
        params : str
            specify the query parameters
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_data_item_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            storage_id=storage_id,
            params=params,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_data_item_with_http_info(
        self,
        item_name: Annotated[
            Optional[StrictStr],
            Field(description="could be empty, in which case the first 1000 items are returned."),
        ] = None,
        oid: Annotated[
            Optional[StrictStr],
            Field(description="Return data_items referred to by the OID provided."),
        ] = None,
        uid: Annotated[
            Optional[StrictStr],
            Field(description="Return data_item referred to by the UID provided."),
        ] = None,
        storage_id: Annotated[
            Optional[StrictStr],
            Field(description="Return data_item referred to by a given storage_id."),
        ] = None,
        params: Annotated[
            Optional[StrictStr], Field(description="specify the query parameters")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Optional[object]]]:
        """Query Data Item

        Query a data_item.  At least one of item_name, oid, uid, or params is required.

        Parameters
        ----------
        item_name : str
            could be empty, in which case the first 1000 items are
            returned.
        oid : str
            Return data_items referred to by the OID provided.
        uid : str
            Return data_item referred to by the UID provided.
        storage_id : str
            Return data_item referred to by a given storage_id.
        params : str
            specify the query parameters
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_data_item_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            storage_id=storage_id,
            params=params,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_data_item_without_preload_content(
        self,
        item_name: Annotated[
            Optional[StrictStr],
            Field(description="could be empty, in which case the first 1000 items are returned."),
        ] = None,
        oid: Annotated[
            Optional[StrictStr],
            Field(description="Return data_items referred to by the OID provided."),
        ] = None,
        uid: Annotated[
            Optional[StrictStr],
            Field(description="Return data_item referred to by the UID provided."),
        ] = None,
        storage_id: Annotated[
            Optional[StrictStr],
            Field(description="Return data_item referred to by a given storage_id."),
        ] = None,
        params: Annotated[
            Optional[StrictStr], Field(description="specify the query parameters")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Data Item

        Query a data_item.  At least one of item_name, oid, uid, or params is required.

        Parameters
        ----------
        item_name : str
            could be empty, in which case the first 1000 items are
            returned.
        oid : str
            Return data_items referred to by the OID provided.
        uid : str
            Return data_item referred to by the UID provided.
        storage_id : str
            Return data_item referred to by a given storage_id.
        params : str
            specify the query parameters
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_data_item_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            storage_id=storage_id,
            params=params,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _query_data_item_serialize(
        self,
        item_name,
        oid,
        uid,
        storage_id,
        params,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if item_name is not None:

            _query_params.append(("item_name", item_name))

        if oid is not None:

            _query_params.append(("oid", oid))

        if uid is not None:

            _query_params.append(("uid", uid))

        if storage_id is not None:

            _query_params.append(("storage_id", storage_id))

        if params is not None:

            _query_params.append(("params", params))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/request/query_data_item",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def query_deleted(
        self,
        uid: Annotated[
            Optional[StrictStr], Field(description="The UID to be checked, optional.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Optional[object]]:
        """Query Deleted

        Query for all deleted data_items using the deleted state.

        Parameters
        ----------
        uid : str
            The UID to be checked, optional.
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_deleted_serialize(
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_deleted_with_http_info(
        self,
        uid: Annotated[
            Optional[StrictStr], Field(description="The UID to be checked, optional.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Optional[object]]]:
        """Query Deleted

        Query for all deleted data_items using the deleted state.

        Parameters
        ----------
        uid : str
            The UID to be checked, optional.
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_deleted_serialize(
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_deleted_without_preload_content(
        self,
        uid: Annotated[
            Optional[StrictStr], Field(description="The UID to be checked, optional.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Deleted

        Query for all deleted data_items using the deleted state.

        Parameters
        ----------
        uid : str
            The UID to be checked, optional.
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_deleted_serialize(
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _query_deleted_serialize(
        self,
        uid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if uid is not None:

            _query_params.append(("uid", uid))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/request/query_deleted",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def query_exists(
        self,
        item_name: Annotated[Optional[StrictStr], Field(description="optional item_name")] = None,
        oid: Annotated[
            Optional[StrictStr], Field(description="the oid to be searched for")
        ] = None,
        uid: Annotated[
            Optional[StrictStr], Field(description="this returns only one storage_id")
        ] = None,
        ready: Annotated[
            Optional[StrictBool], Field(description="whether the item must be in ready state.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bool:
        """Query Exists

        Query to check for existence of a data_item.

        Parameters
        ----------
        item_name : str
            optional item_name
        oid : str
            the oid to be searched for
        uid : str
            this returns only one storage_id
        ready : bool
            whether the item must be in ready state.
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_exists_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            ready=ready,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bool",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_exists_with_http_info(
        self,
        item_name: Annotated[Optional[StrictStr], Field(description="optional item_name")] = None,
        oid: Annotated[
            Optional[StrictStr], Field(description="the oid to be searched for")
        ] = None,
        uid: Annotated[
            Optional[StrictStr], Field(description="this returns only one storage_id")
        ] = None,
        ready: Annotated[
            Optional[StrictBool], Field(description="whether the item must be in ready state.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bool]:
        """Query Exists

        Query to check for existence of a data_item.

        Parameters
        ----------
        item_name : str
            optional item_name
        oid : str
            the oid to be searched for
        uid : str
            this returns only one storage_id
        ready : bool
            whether the item must be in ready state.
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_exists_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            ready=ready,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bool",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_exists_without_preload_content(
        self,
        item_name: Annotated[Optional[StrictStr], Field(description="optional item_name")] = None,
        oid: Annotated[
            Optional[StrictStr], Field(description="the oid to be searched for")
        ] = None,
        uid: Annotated[
            Optional[StrictStr], Field(description="this returns only one storage_id")
        ] = None,
        ready: Annotated[
            Optional[StrictBool], Field(description="whether the item must be in ready state.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Exists

        Query to check for existence of a data_item.

        Parameters
        ----------
        item_name : str
            optional item_name
        oid : str
            the oid to be searched for
        uid : str
            this returns only one storage_id
        ready : bool
            whether the item must be in ready state.
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_exists_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            ready=ready,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bool",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _query_exists_serialize(
        self,
        item_name,
        oid,
        uid,
        ready,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if item_name is not None:

            _query_params.append(("item_name", item_name))

        if oid is not None:

            _query_params.append(("oid", oid))

        if uid is not None:

            _query_params.append(("uid", uid))

        if ready is not None:

            _query_params.append(("ready", ready))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/request/query_exists",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def query_exists_and_ready(
        self,
        item_name: Annotated[Optional[StrictStr], Field(description="optional item_name")] = None,
        oid: Annotated[
            Optional[StrictStr], Field(description="the oid to be searched for")
        ] = None,
        uid: Annotated[
            Optional[StrictStr], Field(description="this returns only one storage_id")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bool:
        """Query Exists And Ready

        Check whether a data_item exists and is in ready state.

        Parameters
        ----------
        item_name : str
            optional item_name
        oid : str
            the oid to be searched for
        uid : str
            this returns only one storage_id
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_exists_and_ready_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bool",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_exists_and_ready_with_http_info(
        self,
        item_name: Annotated[Optional[StrictStr], Field(description="optional item_name")] = None,
        oid: Annotated[
            Optional[StrictStr], Field(description="the oid to be searched for")
        ] = None,
        uid: Annotated[
            Optional[StrictStr], Field(description="this returns only one storage_id")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bool]:
        """Query Exists And Ready

        Check whether a data_item exists and is in ready state.

        Parameters
        ----------
        item_name : str
            optional item_name
        oid : str
            the oid to be searched for
        uid : str
            this returns only one storage_id
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_exists_and_ready_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bool",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_exists_and_ready_without_preload_content(
        self,
        item_name: Annotated[Optional[StrictStr], Field(description="optional item_name")] = None,
        oid: Annotated[
            Optional[StrictStr], Field(description="the oid to be searched for")
        ] = None,
        uid: Annotated[
            Optional[StrictStr], Field(description="this returns only one storage_id")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Exists And Ready

        Check whether a data_item exists and is in ready state.

        Parameters
        ----------
        item_name : str
            optional item_name
        oid : str
            the oid to be searched for
        uid : str
            this returns only one storage_id
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_exists_and_ready_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "bool",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _query_exists_and_ready_serialize(
        self,
        item_name,
        oid,
        uid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if item_name is not None:

            _query_params.append(("item_name", item_name))

        if oid is not None:

            _query_params.append(("oid", oid))

        if uid is not None:

            _query_params.append(("uid", uid))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/request/query_exist_and_ready",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def query_expired(
        self,
        offset: Annotated[
            Optional[StrictStr], Field(description="optional offset for the query")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Optional[object]]:
        """Query Expired

        Query for all expired data_items using the uid_expiration timestamp.

        Parameters
        ----------
        offset : str
            optional offset for the query
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_expired_serialize(
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_expired_with_http_info(
        self,
        offset: Annotated[
            Optional[StrictStr], Field(description="optional offset for the query")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Optional[object]]]:
        """Query Expired

        Query for all expired data_items using the uid_expiration timestamp.

        Parameters
        ----------
        offset : str
            optional offset for the query
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_expired_serialize(
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_expired_without_preload_content(
        self,
        offset: Annotated[
            Optional[StrictStr], Field(description="optional offset for the query")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Expired

        Query for all expired data_items using the uid_expiration timestamp.

        Parameters
        ----------
        offset : str
            optional offset for the query
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_expired_serialize(
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _query_expired_serialize(
        self,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if offset is not None:

            _query_params.append(("offset", offset))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/request/query_expired",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def query_item_storage(
        self,
        item_name: Annotated[Optional[StrictStr], Field(description="optional item_name")] = None,
        oid: Annotated[
            Optional[StrictStr], Field(description="the oid to be searched for")
        ] = None,
        uid: Annotated[
            Optional[StrictStr], Field(description="this returns only one storage_id")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Optional[object]]:
        """Query Item Storage

        Query for the storage_ids of all backends holding a copy of a data_item.  Either an item_name or a OID have to be provided.

        Parameters
        ----------
        item_name : str
            optional item_name
        oid : str
            the oid to be searched for
        uid : str
            this returns only one storage_id
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_item_storage_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_item_storage_with_http_info(
        self,
        item_name: Annotated[Optional[StrictStr], Field(description="optional item_name")] = None,
        oid: Annotated[
            Optional[StrictStr], Field(description="the oid to be searched for")
        ] = None,
        uid: Annotated[
            Optional[StrictStr], Field(description="this returns only one storage_id")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Optional[object]]]:
        """Query Item Storage

        Query for the storage_ids of all backends holding a copy of a data_item.  Either an item_name or a OID have to be provided.

        Parameters
        ----------
        item_name : str
            optional item_name
        oid : str
            the oid to be searched for
        uid : str
            this returns only one storage_id
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_item_storage_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_item_storage_without_preload_content(
        self,
        item_name: Annotated[Optional[StrictStr], Field(description="optional item_name")] = None,
        oid: Annotated[
            Optional[StrictStr], Field(description="the oid to be searched for")
        ] = None,
        uid: Annotated[
            Optional[StrictStr], Field(description="this returns only one storage_id")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Item Storage

        Query for the storage_ids of all backends holding a copy of a data_item.  Either an item_name or a OID have to be provided.

        Parameters
        ----------
        item_name : str
            optional item_name
        oid : str
            the oid to be searched for
        uid : str
            this returns only one storage_id
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_item_storage_serialize(
            item_name=item_name,
            oid=oid,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _query_item_storage_serialize(
        self,
        item_name,
        oid,
        uid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if item_name is not None:

            _query_params.append(("item_name", item_name))

        if oid is not None:

            _query_params.append(("oid", oid))

        if uid is not None:

            _query_params.append(("uid", uid))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/request/query_item_storage",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def query_new(
        self,
        check_date: Annotated[StrictStr, Field(description="the UTC starting date (exclusive)")],
        uid: Annotated[
            Optional[StrictStr], Field(description="The UID to be checked, optional.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Optional[object]]:
        """Query New

        Query for all data_items newer than the date provided.

        Parameters
        ----------
        check_date : str
            the UTC starting date (exclusive) (required)
        uid : str
            The UID to be checked, optional.
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_new_serialize(
            check_date=check_date,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_new_with_http_info(
        self,
        check_date: Annotated[StrictStr, Field(description="the UTC starting date (exclusive)")],
        uid: Annotated[
            Optional[StrictStr], Field(description="The UID to be checked, optional.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Optional[object]]]:
        """Query New

        Query for all data_items newer than the date provided.

        Parameters
        ----------
        check_date : str
            the UTC starting date (exclusive) (required)
        uid : str
            The UID to be checked, optional.
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_new_serialize(
            check_date=check_date,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_new_without_preload_content(
        self,
        check_date: Annotated[StrictStr, Field(description="the UTC starting date (exclusive)")],
        uid: Annotated[
            Optional[StrictStr], Field(description="The UID to be checked, optional.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query New

        Query for all data_items newer than the date provided.

        Parameters
        ----------
        check_date : str
            the UTC starting date (exclusive) (required)
        uid : str
            The UID to be checked, optional.
        _request_timeout : int, tuple(int, int), optional
            timeout setting for this request. If one number provided, it
            will be total request timeout. It can also be a pair (tuple)
            of (connection, read) timeouts.
        _request_auth : dict, optional
            set to override the auth_settings for an a single request;
            this effectively ignores the authentication in the spec for
            a single request.
        _content_type : str, Optional
            force content-type for the request.
        _headers : dict, optional
            set to override the headers for a single request; this
            effectively ignores the headers in the spec for a single
            request.
        _host_index : int, optional
            set to override the host_index for a single request; this
            effectively ignores the host_index in the spec for a single
            request.

        Returns
        -------
        unknown
            Returns the result object.
        """
        # noqa: E501

        _param = self._query_new_serialize(
            check_date=check_date,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[Optional[object]]",
            "422": "HTTPValidationError",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _query_new_serialize(
        self,
        check_date,
        uid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if check_date is not None:

            _query_params.append(("check_date", check_date))

        if uid is not None:

            _query_params.append(("uid", uid))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/request/query_new",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
